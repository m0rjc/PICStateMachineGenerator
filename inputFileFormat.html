<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Sep 26, 2011 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PIC State Machine Generator - </title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20110926" />
    <meta http-equiv="Content-Language" content="en" />
        
  </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                State machine generator for PIC Microcontrollers
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2011-09-26</span>
                  &nbsp;| <span id="projectVersion">Version: 0.0.1-SNAPSHOT</span>
                      </div>
            <div class="xright">        
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Project Documentation</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="Introduction">Introduction</a>
            </li>
                  <li class="none">
                          <a href="anatomyOfAStateTransition.html" title="Anatomy of a State Transition">Anatomy of a State Transition</a>
            </li>
                  <li class="none">
            <strong>Input File Format</strong>
          </li>
          </ul>
                       <h5>Maven Reports</h5>
                  <ul>
                                                                                                                                                                                                  <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                          <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Input File Format<a name="Input_File_Format"></a></h2><p>The State Machine Generator accepts an XML input file. This file describes the state machine, the variables it accesses, unit tests for the state machine and the required output from the generator.</p><div class="section"><h3>File Header<a name="File_Header"></a></h3><div class="source"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;StateGeneratorRun xmlns=&quot;http://net.raynet-uk.m0rjc.picprojects/stategenerator&quot;&gt;
    &lt;Model name=&quot;gps&quot; root=&quot;root&quot; inputVariable=&quot;gpsInput&quot;&gt;
        ....
    &lt;/Model&gt;
    &lt;UnitTests&gt;
        ....
    &lt;/UnitTests&gt;
    &lt;Output&gt;
        ....
    &lt;/Output&gt;
&lt;/StateGeneratorRun&gt;    
</pre></div><p>The input file is an XML document. The root element is StateGeneratorRun. This contains the sections that make up the file.</p></div><div class="section"><h3>Model Section<a name="Model_Section"></a></h3><div class="source"><pre>&lt;Model name=&quot;gps&quot; root=&quot;root&quot; inputVariable=&quot;gpsInput&quot;&gt;
    &lt;Symbols&gt;
    ...
    &lt;/Symbols&gt;
    &lt;Nodes&gt;
    ...
    &lt;/Nodes&gt;
&lt;/Model&gt;
</pre></div><p>The <b>name</b> is a short name for the model. It must be a valid MPASM symbol. It will be used in label generation and may be used to produce output file names.</p><p>The <b>root</b> is the name of the Initial State for the model. This is the state that will be set by the initialisation method and the fallback state should a Node see input that it does not have a transition for.</p><p>The <b>inputVariable</b> is the name of the variable that contains the state machine's input. It is a single byte variable. It must be declared in the Symbols section of the file.</p></div><div class="section"><h3>Variables Subsection<a name="Variables_Subsection"></a></h3><div class="source"><pre>&lt;Symbols&gt;
        &lt;Symbol name=&quot;gpsInput&quot; loc=&quot;accessram&quot; decl=&quot;global&quot; /&gt;
        &lt;Symbol name=&quot;gpsTime&quot; size=&quot;6&quot; loc=&quot;page1&quot; decl=&quot;global&quot; /&gt;
        ...
&lt;/Symbols&gt;
</pre></div><p>The <b>name</b> is the name of the symbol. It must be a valid MPASM symbol name.</p><p>The <b>loc</b> defines the location of the symbol. Valid values are</p><ul><li><b>accessram</b> is a variable stored in the PIC18's access ram. For non-PIC18 or PIC18 in extended mode (when supported) this is a hint that the variable should be easy to access if possible. On PIC18 the variable will be declared in a UDATA_SHR section, and access will use the &quot;A&quot; access bank modifier.</li><li><b>rom</b> declares a symbol defined in ROM. This is used for external method declarations.</li><li><b>page0</b> to <b>page15</b> are banked pages. The generated code will not ensure that the variables are placed in these pages, but will output UDATA sections with names that the user should configure in their linker script. The generated code will use BANKSEL statements where needed to access these variables.</li></ul><p>The <b>size</b> is the size in bytes to allocate. It will default to 1 byte.</p><p>The <b>decl</b> controls which code is responsible for declaring storage for the variable. It is optional and defaults to &quot;internal&quot;. Values are</p><ul><li><b>internal</b> Storage is declared in the generated code. The symbol is not made GLOBAL.</li><li><b>global</b> Storage is declared in the generated code. The symbol is marked GLOBAL. An EXTERN entry will be generated in the include file.</li><li><b>extern</b> Storage is not declared in the generated code. The symbol is marked EXTERN.</li><li><b>none</b> No declaration is made in the generated code. It is assumed that the symbol is provided by any include file used. This may be used for a Special Function Register.</li></ul><div class="section"><h4>Flags<a name="Flags"></a></h4><div class="source"><pre>&lt;Symbol name=&quot;gpsFlags&quot; loc=&quot;accessram&quot; decl=&quot;global&quot;&gt;
        &lt;Flags&gt;
                &lt;Flag&gt;FLAG_GPS_NEW_POSITION&lt;/Flag&gt;
                &lt;Flag&gt;FLAG_GPS_NORTH&lt;/Flag&gt;
                &lt;Flag&gt;FLAG_GPS_EAST&lt;/Flag&gt;
        &lt;/Flags&gt;
&lt;/Symbol&gt;
</pre></div><p>Flags are bitfields. The size of the variable will be calculated as required to contain the amount of flags. It will always be greater than or equal to the size specified as <b>size</b> if provided.</p><p>Flags are allocated starting from the least significant bit of the first byte, increasing to the most significant bit then to the least significant bit of the second byte and so on.</p></div></div><div class="section"><h3>Nodes Subsection<a name="Nodes_Subsection"></a></h3><div class="source"><pre>&lt;Nodes&gt;
        &lt;Node name=&quot;root&quot;&gt;
                &lt;Transition input=&quot;'$'&quot; target=&quot;dollar&quot; /&gt;
                ...
        &lt;/Node&gt;
        &lt;Node name=&quot;dollar&quot;&gt;
                &lt;Script description=&quot;Read a GPGGA locaton string&quot;&gt;
                ...
                &lt;/Script&gt;
        &lt;/Node&gt;
        ...
&lt;/Nodes&gt;
</pre></div><p>Each Node element defines a named node in the system. Node elements optionally contain a list of entry conditions and commands followed by a list of Transitions and Scripts. Transitions and Scripts may be defined in any order. They are evaluated in the order they are defined, so should be defined with most specific conditions first.</p><div class="source"><pre>&lt;Node name=&quot;root&quot;&gt;
        &lt;EntryConditions&gt;
                ...     
        &lt;/EntryConditions&gt;
        &lt;EntryCommands&gt;
                ...
        &lt;/EntryCommands&gt;
        ...
&lt;/Node&gt;
</pre></div><div class="section"><h4>Entry Conditions<a name="Entry_Conditions"></a></h4><p>The EntryConditions element is optional. The following Condition is supported</p><div class="source"><pre>&lt;FlagCheck variable=&quot;name&quot; flag=&quot;FLAG_NAME&quot; value=&quot;true&quot;/&gt;
</pre></div><p><b>variable</b> is the name of the variable containing the flag.</p><p><b>flag</b> is the name of the flag, defined using a Flag element.</p><p><b>value</b> is the expected value, true or false.</p></div><div class="section"><h4>Entry Commands<a name="Entry_Commands"></a></h4><p>The EntryCommands element is optional. It contains any of the following commands in any order. </p><p>Entry Commands are executed as the state machine switches to the node at the end of handling the previous node.</p><div class="section"><h5>Clear Value<a name="Clear_Value"></a></h5><div class="source"><pre>&lt;ClearValue&gt;symbolName&lt;/ClearValue&gt;
</pre></div><p>Clear the variable with the given name. All bytes are cleared.</p></div><div class="section"><h5>Clear Indexed Value<a name="Clear_Indexed_Value"></a></h5><div class="source"><pre>&lt;ClearIndexedValue variable=&quot;name&quot; indexer=&quot;indexVariable&quot;/&gt;
</pre></div><p>Clear the byte at the given index within the given variable.</p><p><b>variable</b> is the variable that contains the array to be accessed.</p><p><b>indexer</b> is the variable containing the offset into the array.</p></div><div class="section"><h5>Store Value <a name="Store_Value"></a></h5><div class="source"><pre>&lt;StoreValue source=&quot;sourceVariable&quot; 
            destination=&quot;destinationSymbol&quot; destinationIndexer=&quot;indexer&quot;/&gt;
</pre></div><p><b>sourceVariable</b> is the variable to copy the value from. Currently this variable must be a single byte value. If this is not provided then the state model's input variable is used.</p><p><b>destination</b> is the variable to copy to.</p><p>If <b>destinationIndexer</b> is provided then this is a variable contianing and offset into the destination array. If not provided then no indexing is used. </p></div><div class="section"><h5>Set Flag<a name="Set_Flag"></a></h5><div class="source"><pre>&lt;SetFlag variable=&quot;name&quot; flag=&quot;FLAG_NAME&quot; value=&quot;true&quot;/&gt;
</pre></div><p>Set the flag <b>FLAG_NAME</b> within the given flag <b>variable</b> to the required value.</p></div><div class="section"><h5>Call<a name="Call"></a></h5><div class="source"><pre>&lt;Call&gt;methodName&lt;/Call&gt;
</pre></div><p>Results in a CALL statement.</p></div></div><div class="section"><h4>Transitions<a name="Transitions"></a></h4><div class="source"><pre>&lt;Transition input=&quot;'0'-'9'&quot; target=&quot;state1234&quot;&gt;
        &lt;Conditions&gt;
                ....
        &lt;/Conditions&gt;
        &lt;Commands&gt;
                ....
        &lt;/Commands&gt;
&lt;/Transition&gt;
</pre></div><p>The Transition element generates a transition from the contianing node.</p><p>The <b>target</b> attribute is required. It contains the name of the node to transition to when the input condition is satisfied.</p><p>The <b>Conditions</b> are optional. The set of possible Conditions is the same as the possible EntryConditions for a Node.</p><p>The <b>input</b> attribute is optional. If provided it can contain a value in any of the following forms:</p><table border="1" class="bodyTable"><tr class="a"><td align="left"><b>12</b></td><td align="left">a decimal number</td></tr><tr class="b"><td align="left"><b>0x1A</b></td><td align="left">hexadecimal number</td></tr><tr class="a"><td align="left"><b>'a'</b></td><td align="left">a character</td></tr><tr class="b"><td align="left">*</td><td align="left">matches any input.</td></tr></table><p>These forms may be combined using a '-' separator to give a range. </p><p>The <b>Commands</b> are optional. These are commands to execute when the transition executes. They are executed after any entry conditions for the target node are checked, and before any entry commands for the target node are executed. The set of possible commands is the same as the EntryCommands element in a Node.</p></div><div class="section"><h4>Scripts<a name="Scripts"></a></h4><p>Scripts provide an easy way to build a state machine designed to match a given input. Multiple scripts may be defined from a given node. If they start with the same input then they will be combined as needed.</p><p>A Script is a list of elements. Node generating elements create a transition or transitions leading to a new node. &quot;GuardCondition&quot; and &quot;Commands&quot; elements create Entry Conditions and Entry Commands on the <i>current node</i>. The <i>current node</i> starts off as the Node that contains the script. Each node generating element ends in a new empty <i>current node</i>.</p><p><b>Because of this a Script should not start with a Condition or Command element. It will be applied to the node that contains the script!</b></p><p>The Script element is</p><div class="source"><pre>&lt;Script description=&quot;Read a GPGGA location string&quot;&gt;
&lt;/Script&gt;
</pre></div><p>The <b>description</b> attribute is optional.</p><div class="section"><h5>Literal Text<a name="Literal_Text"></a></h5><div class="source"><pre>&lt;Literal&gt;GPGGA&lt;/Literal&gt;
</pre></div><p>A &quot;Literal&quot; will create a chain of nodes that will read the given literal text. In this example the <tt>current node</tt> will have a new transition on the letter 'G' which will lead to a new node. This node will have a transition on the letter 'P', and so forth until a transition on the letter 'A' leads to the new <i>current node</i>.</p><p>If the <i>current node</i> already had a transition on the letter 'G' it would have been reused.</p></div><div class="section"><h5>Numbers<a name="Numbers"></a></h5><div class="source"><pre>&lt;Numbers min=&quot;6&quot; max=&quot;6&quot; store=&quot;gpsTime&quot; /&gt;
</pre></div><p>Read 6 digits. Store them in the variable&quot;gpsTime&quot;.</p><p><b>min</b> is the minimum amount of numbers to read. If min is zero then no new <i>current node</i> is created.</p><p><b>max</b> is the maximum amount of numbers to read.</p><p><b>store</b> is optional. This is the variable to store the numbers in. The numbers are stored as ASCII values. If max is greater than min then a null terminated string is used, otherwise the array will contain just the input bytes.</p></div><div class="section"><h5>Choices<a name="Choices"></a></h5><div class="source"><pre>&lt;Choices&gt;
        &lt;Choice input=&quot;'S'&quot;&gt;
                &lt;Commands&gt;
                        &lt;SetFlag flag=&quot;FLAG_GPS_NORTH&quot; variable=&quot;gpsFlags&quot; value=&quot;false&quot; /&gt;
                &lt;/Commands&gt;
        &lt;/Choice&gt;
        &lt;Choice input=&quot;'N'&quot;&gt;
                &lt;Commands&gt;
                        &lt;SetFlag flag=&quot;FLAG_GPS_NORTH&quot; variable=&quot;gpsFlags&quot; value=&quot;true&quot; /&gt;
                &lt;/Commands&gt;
        &lt;/Choice&gt;
&lt;/Choices&gt;
</pre></div></div><div class="section"><h5>Skip To<a name="Skip_To"></a></h5><div class="source"><pre>&lt;SkipTo&gt;
        &lt;Choice input=&quot;'$'&quot; target=&quot;dollar&quot; /&gt;
        &lt;Choice input=&quot;','&quot; /&gt;
&lt;/SkipTo&gt;
</pre></div></div></div></div><div class="section"><h3>Unit Test Section<a name="Unit_Test_Section"></a></h3></div><div class="section"><h3>Output Section<a name="Output_Section"></a></h3><div class="source"><pre>&lt;Output&gt;
        &lt;Pic18 processor=&quot;18F14K50&quot;&gt;
                &lt;Include&gt;p18f14k50.inc&lt;/Include&gt;
        &lt;/Pic18&gt;
&lt;/Output&gt;
</pre></div><div class="section"><h4>The Pic18 Target<a name="The_Pic18_Target"></a></h4><div class="source"><pre>&lt;Pic18 processor=&quot;18F14K50&quot; largeRomModel=&quot;false&quot; outputBaseName=&quot;generated/gps&quot;&gt;
        &lt;Include&gt;p18f14k50.inc&lt;/Include&gt;
        &lt;ReturnLine&gt;RETURN&lt;/ReturnLine&gt;
&lt;/Pic18&gt;
</pre></div><p>The Pic18 target outputs three files, assembler code (.asm), assembler include (.inc) and C include (.h).</p><p>The <b>processor</b> is the target processor which will be output as a &quot;list p=&quot; directive.</p><p>If <b>largeRomModel</b> is true then 3 byte pointers will be used, otherwise the default is to use 2 byte pointers.</p><p>The <b>outputBaseName</b> is the base name for generated files. It will default to the Model Name.</p><p>Each <b>Include</b> will be output as a #include.</p><p>Each <b>ReturnLine</b> will be output in order to return control to the calling program. For example code running in an interrupt handler may wish to use the RETFIE instruction or GOTO an interrupt cleanup block. If no return lines are given then the default is to output a RETURN statement.</p></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">Copyright &#169;                    2011
                      This is a personal project, currently not associated with any organisation..
            All Rights Reserved.      
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
